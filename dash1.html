<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Future Flappy Bird</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #0d1b2a, #1b263b);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: 'Orbitron', sans-serif;
    }
    canvas {
      max-width: 100%;
      max-height: 100%;
      width: 400px;
      height: 600px;
      border: 3px solid #00ddeb;
      box-shadow: 0 0 30px #00ddeb;
      background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="600"><rect width="100%" height="100%" fill="transparent"/><g fill="none" stroke="#00ddeb" stroke-width="1" opacity="0.2"><circle cx="100" cy="100" r="50"/><circle cx="300" cy="500" r="70"/><path d="M0 200 H400 M0 400 H400"/></g></svg>');
    }
    #score, #highScore, #startMessage {
      position: absolute;
      color: #00ddeb;
      font-size: 20px;
      text-shadow: 0 0 15px #00ddeb;
      user-select: none;
    }
    #score { top: 10px; left: 10px; }
    #highScore { top: 40px; left: 10px; }
    #startMessage {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 28px;
      text-align: center;
      background: rgba(0, 29, 61, 0.7);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ddeb;
    }
    #gameLink {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #ff2e63;
      font-size: 18px;
      text-decoration: none;
      text-shadow: 0 0 10px #ff2e63;
      padding: 5px 10px;
      border: 2px solid #ff2e63;
      border-radius: 5px;
      transition: all 0.3s;
    }
    #gameLink:hover {
      background: #ff2e63;
      color: #0d1b2a;
      box-shadow: 0 0 15px #ff2e63;
    }
    @media (max-width: 500px) {
      canvas {
        width: 100%;
        height: 80vh;
      }
      #score, #highScore { font-size: 16px; }
      #startMessage { font-size: 20px; padding: 15px; }
      #gameLink { font-size: 14px; padding: 3px 8px; }
    }
    @keyframes pulse {
      0% { opacity: 0.6; }
      50% { opacity: 1; }
      100% { opacity: 0.6; }
    }
    #startMessage { animation: pulse 2s infinite; }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <a id="gameLink" href="index.html">Game Menu</a>
  <canvas id="gameCanvas"></canvas>
  <div id="score">Score: 0</div>
  <div id="highScore">High Score: 0</div>
  <div id="startMessage">Tap or Press SPACE to Start</div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const highScoreDisplay = document.getElementById('highScore');
    const startMessage = document.getElementById('startMessage');

    function resizeCanvas() {
      const maxWidth = window.innerWidth * 0.9;
      const maxHeight = window.innerHeight * 0.8;
      const aspectRatio = 400 / 600;
      let width = maxWidth;
      let height = width / aspectRatio;
      if (height > maxHeight) {
        height = maxHeight;
        width = height * aspectRatio;
      }
      canvas.width = width;
      canvas.height = height;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    let bird = {
      x: canvas.width * 0.25,
      y: canvas.height / 2,
      radius: canvas.width * 0.04,
      velocity: 0,
      gravity: 0.3,
      lift: -8
    };

    let pipes = [];
    let score = 0;
    let highScore = localStorage.getItem('highScore') || 0;
    let gameStarted = false;
    let gameOver = false;
    const pipeWidth = canvas.width * 0.15;
    const pipeGap = canvas.height * 0.3;
    const pipeSpeed = 1.5;
    let pipeFrequency = 120;
    let frameCount = 0;

    highScoreDisplay.textContent = `High Score: ${highScore}`;

    function drawBird() {
      ctx.beginPath();
      ctx.arc(bird.x, bird.y, bird.radius, 0, Math.PI * 2);
      ctx.fillStyle = '#ff2e63';
      ctx.shadowBlur = 25;
      ctx.shadowColor = '#ff2e63';
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.closePath();
    }

    function drawPipes() {
      pipes.forEach(pipe => {
        ctx.fillStyle = '#00ddeb';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ddeb';
        ctx.fillRect(pipe.x, 0, pipeWidth, pipe.top);
        ctx.fillRect(pipe.x, pipe.top + pipeGap, pipeWidth, canvas.height - pipe.top - pipeGap);
        ctx.shadowBlur = 0;
      });
    }

    function updateBird() {
      if (gameStarted) {
        bird.velocity += bird.gravity;
        bird.y += bird.velocity;
        if (bird.y + bird.radius > canvas.height * 0.95 || bird.y - bird.radius < canvas.height * 0.05) {
          gameOver = true;
        }
      }
    }

    function updatePipes() {
      if (gameStarted) {
        if (frameCount % pipeFrequency === 0) {
          let topHeight = Math.random() * (canvas.height - pipeGap - canvas.height * 0.2) + canvas.height * 0.1;
          pipes.push({ x: canvas.width, top: topHeight, scored: false });
        }
        pipes.forEach(pipe => {
          pipe.x -= pipeSpeed;
          if (pipe.x + pipeWidth < 0) {
            pipes.shift();
          }
          if (!pipe.scored && pipe.x + pipeWidth < bird.x) {
            score++;
            pipe.scored = true;
            scoreDisplay.textContent = `Score: ${score}`;
          }
        });
    }
}

    function checkCollision() {
      pipes.forEach(pipe => {
        if (
          bird.x + bird.radius * 0.8 > pipe.x &&
          bird.x - bird.radius * 0.8 < pipe.x + pipeWidth &&
          (bird.y - bird.radius * 0.8 < pipe.top || bird.y + bird.radius * 0.8 > pipe.top + pipeGap)
        ) {
          gameOver = true;
        }
      });
    }

    function resetGame() {
      bird.y = canvas.height / 2;
      bird.velocity = 0;
      pipes = [];
      score = 0;
      scoreDisplay.textContent = `Score: ${score}`;
      gameStarted = false;
      gameOver = false;
      startMessage.style.display = 'block';
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBird();
      drawPipes();
      updateBird();
      updatePipes();
      checkCollision();
      frameCount++;

      if (gameOver) {
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('highScore', highScore);
          highScoreDisplay.textContent = `High Score: ${highScore}`;
        }
        resetGame();
      }

      requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        if (!gameStarted && !gameOver) {
          gameStarted = true;
          startMessage.style.display = 'none';
        }
        bird.velocity = bird.lift;
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (!gameStarted && !gameOver) {
        gameStarted = true;
        startMessage.style.display = 'none';
      }
      bird.velocity = bird.lift;
    });

    canvas.addEventListener('click', () => {
      if (!gameStarted && !gameOver) {
        gameStarted = true;
        startMessage.style.display = 'none';
      }
      bird.velocity = bird.lift;
    });

    gameLoop();
  </script>
</body>
</html>